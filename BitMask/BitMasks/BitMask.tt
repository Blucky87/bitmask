<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #><#
    const int FieldCount = 2;
    const int BitsPerField = 8 * sizeof(UInt64);
    const int BitSize = FieldCount * BitsPerField;
#>using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace BitMasks
{
    using DataType = UInt64;

    public struct BitMask<#= BitSize #> : IEquatable<BitMask<#= BitSize #>>
    {
        public static readonly BitMask<#= BitSize #> None = new BitMask<#= BitSize #>(bits: new int[0]);

        private const int MaskDataSize = <#= FieldCount #>;
        private const int BitsPerData = 8 * sizeof(DataType);
        private const int MaxBitIndex = (MaskDataSize * BitsPerData) - 1;

        public const int BitSize = MaskDataSize * BitsPerData;

<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
        private DataType _field<#= i #>;
<#
    }
#>

        public BitMask<#= BitSize #>(int[] bits)
        {
<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
            _field<#= i #> = 0;
<#
    }
#>

            for (int i = 0; i < bits.Length; ++i)
            {
                ref var bit = ref bits[i];

                if (bit < 0 || bit > MaxBitIndex)
                    throw new Exception($"Attempted to set bit #{bit}, but the maximum is {MaxBitIndex}");

                var dataIndex = bit / BitsPerData;
                var bitIndex = bit % BitsPerData;

                var mask = (DataType) 1 << bitIndex;

                switch (dataIndex)
                {
<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
                    case <#= i #>:
                        _field<#= i #> |= mask;
                        break;
<#
    }
#>
                    default:
                        throw new Exception($"Nonexistent field: {dataIndex}");
                }
            }
        }

        public bool this[int index]
        {
            get
            {
                if (index < 0 || index > MaxBitIndex)
                    throw new Exception($"Invalid bit index: {index}");

                var dataIndex = index / BitsPerData;
                var bitIndex = index % BitsPerData;

                switch (dataIndex)
                {
<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
                    case <#= i #>:
                        return (_field<#= i #> & ((DataType) 1 << bitIndex)) != 0;
<#
    }
#>
                    default:
                        return false;
                }
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(BitMask<#= BitSize #> other)
        {
<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
            if (_field<#= i #> != other._field<#= i #>)
                return false;

<#
    }
#>
            return true;
        }

        public override bool Equals(object obj)
        {
            if (obj is BitMask<#= BitSize #>)
                return Equals((BitMask<#= BitSize #>) obj);

            return base.Equals(obj);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(BitMask<#= BitSize #> mask1, BitMask<#= BitSize #> mask2)
        {
            return mask1.Equals(mask2);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(BitMask<#= BitSize #> mask1, BitMask<#= BitSize #> mask2)
        {
            return !mask1.Equals(mask2);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static BitMask<#= BitSize #> operator &(BitMask<#= BitSize #> mask1, BitMask<#= BitSize #> mask2)
        {
            var newBitMask = new BitMask<#= BitSize #>();

<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
            newBitMask._field<#= i #> = mask1._field<#= i #> & mask2._field<#= i #>;
<#
    }
#>

            return newBitMask;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static BitMask<#= BitSize #> operator |(BitMask<#= BitSize #> mask1, BitMask<#= BitSize #> mask2)
        {
            var newBitMask = new BitMask<#= BitSize #>();

<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
            newBitMask._field<#= i #> = mask1._field<#= i #> | mask2._field<#= i #>;
<#
    }
#>

            return newBitMask;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static BitMask<#= BitSize #> operator ~(BitMask<#= BitSize #> mask)
        {
            var newBitMask = new BitMask<#= BitSize #>();

<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
            newBitMask._field<#= i #> = ~mask._field<#= i #>;
<#
    }
#>

            return newBitMask;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Has(BitMask<#= BitSize #> mask)
        {
<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
            if ((_field<#= i #> & mask._field<#= i #>) != mask._field<#= i #>)
                return false;

<#
    }
#>
            return true;
        }

        public override string ToString()
        {
            var builder = new StringBuilder();

            var fields = new DataType[MaskDataSize];

<#
    for (int i = 0; i < FieldCount; ++i)
    {
#>
            fields[<#= i #>] = _field<#= i #>;
<#
    }
#>

            for (int i = 0; i < MaskDataSize; ++i)
            {
                var binaryString = Convert.ToString((long) fields[i], 2);

                builder.Append(binaryString.PadLeft(BitsPerData, '0'));
            }

            return builder.ToString();
        }
    }
}
